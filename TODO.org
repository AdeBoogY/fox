* DONE 1й уровень -- connection
  + app, sup
    + connection_pool_sup
      + connection_sup (register with ConnectionName, run Num connection_worker)
  + динамическое создание новых соединений и остановка их
    для каждого {ConnectionName, #amqp_network_params{}} нужно создать connection_sup
    и под ним несколько connection_worker
  + connect
  + reconnect
  + close connection
  + monitor connection


* 2й уровень -- channel
  + create channel
    + по ConnectionName выбрать нужный connection_sup
    + для этого sup обойти все его connection_worker
      и выбрать тот, у кого меньше всего channel

  + subscribe
    + channel_sup (simple_one_for_one), run fox_channel_consumer
    + fox_channel_consumer и  behaviour
    + behaviour будет простой: init и handle
      handle будет получать все возможные события.
    + validate behaviour
    + sample_consumer:init -- declare exchange/queue, bind
    + channel_worker
      и редиректить события в behaviour (sample_consumer)
      передавая туда еще и ChannelPid

  + в test_run наладить публикацию и подписку,
    чтобы получать события в sample_consumer
    + создать канал для sample_consumer
    + в init создать exchange, queue, bind
    + послать сообщение через другой канал
    + получить в sample_consumer

  - close_channel(ConnectionName, ChannelPid) -> ok

  - unsubscribe
    ну и там должен быть вызов sample_channel_consumer:terminate

* 3й уровень -- сценарии использования channel
  channel_worker хранит внутри себя channel (свой собственный, экслюзивный)
  и предоставляет АПИ для основных сценариев:
  - publish (async)
  - publish with confirmation (не документарован, нужно разбираться)
  - declare exchange, declare queue, bind queue
  - subscribe
    - что если мы хотим пописаться на 2 очереди?
  - unsubscribe
  сделаю везде мапы как альтернативу рекордам

** АПИ 3-го уровня нужно продумать:
  - publish(ChannelPid, Data) ?
  - publish_with_confirmation?
    https://www.rabbitmq.com/confirms.html
  - subscribe(ChannelPid, callback, #amqp_consumer{}) ?
    behaviour amqp_consumer
    process_data(ChannelPid, Data) -> ack | reject
    unsubscribe() ?
  - declare exchange, queue, bind

* Мониторинг:
  - connection_worker должен мониторить channel и channel_worker
    перезапускать их, если они упали, заново объявлять и связывать, если нужно
  - connection_worker после reconnect должен создать новые channel и раздать их channel_worker
    ну и те должны заново инициализироваться


* README
документация на весь АПИ
- fox:create_channel/1 -- за канал отвечает потребитель, либа дальше этот канал не использует и не мониторит
как работает либа (структура потоков и т.д.)
- amqp_channel:subscribe мы в АПИ не выставляем, но пользователь может сделать это сам,
  получив канал через create_channel

* samples

* info
http://www.rabbitmq.com/erlang-client-user-guide.html
https://www.rabbitmq.com/confirms.html
