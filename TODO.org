* DONE 1й уровень -- connection
  + app, sup
    + connection_pool_sup
      + connection_sup (register with ConnectionName, run Num connection_worker)
  + динамическое создание новых соединений и остановка их
    для каждого {ConnectionName, #amqp_network_params{}} нужно создать connection_sup
    и под ним несколько connection_worker
  + connect
  + reconnect
  + close connection
  + monitor connection


* DONE 2й уровень -- channel
  + create channel
    + по ConnectionName выбрать нужный connection_sup
    + для этого sup обойти все его connection_worker
      и выбрать тот, у кого меньше всего channel

  + subscribe
    + channel_sup (simple_one_for_one), run fox_channel_consumer
    + fox_channel_consumer и  behaviour
    + behaviour будет простой: init и handle
      handle будет получать все возможные события.
    + validate behaviour
    + sample_consumer:init -- declare exchange/queue, bind
    + channel_worker
      и редиректить события в behaviour (sample_consumer)
      передавая туда еще и ChannelPid

  + в test_run наладить публикацию и подписку,
    чтобы получать события в sample_consumer
    + создать канал для sample_consumer
    + в init создать exchange, queue, bind
    + послать сообщение через другой канал
    + получить в sample_consumer

  + unsubscribe
    + по ChannelPid найти нужный connection_worker
      можно тупо дернуть всех, а сработает тот, кому принадлежит ChannelPid
    + connection_worker должен хранить в своем состоянии все {ChannelPid, SubscriberPid}
    + вызывать fox_channel_consumer:stop
    + вызывать sample_channel_consumer:terminate


* 3й уровень -- сценарии использования channel
АПИ для основных сценариев
сделаю везде мапы как альтернативу рекордам

+ declare_exchange(Name :: binary(), Options :: map())
  record('exchange.declare', {ticket = 0, exchange, type = <<"direct">>, passive = false, durable = false, auto_delete = false, internal = false, nowait = false, arguments = []}).

- delete_exchange(Name :: binary(), Options :: map())
  record('exchange.delete', {ticket = 0, exchange, if_unused = false, nowait = false}).

- declare queue
  record('queue.declare', {ticket = 0, queue = <<"">>, passive = false, durable = false, exclusive = false, auto_delete = false, nowait = false, arguments = []}).

- delete queue
  record('queue.delete', {ticket = 0, queue = <<"">>, if_unused = false, if_empty = false, nowait = false}).

- bind queue
  record('queue.bind', {ticket = 0, queue = <<"">>, exchange, routing_key = <<"">>, nowait = false, arguments = []}).

- unbind queue
  record('queue.unbind', {ticket = 0, queue = <<"">>, exchange, routing_key = <<"">>, arguments = []}).

- rabbit_framing.hrl
  надо бы выяснить смысл всех операций
  может что-то еще нужно добавить в АПИ

- publish (async)

- publish with confirmation (не документарован, нужно разбираться)
  https://www.rabbitmq.com/confirms.html

- subscribe
  - что если мы хотим пописаться на 2 очереди?

+ unsubscribe


* Мониторинг:

- fox_connection_worker должен мониторить channel и fox_channel_consumer
  перезапускать их, если они упали, заново объявлять и связывать, если нужно

- connection_worker после reconnect должен создать новые channel и раздать их channel_worker
  ну и те должны заново инициализироваться

- как все это протестить?


* README

- документация на весь АПИ
  - fox:create_channel/1 -- за канал отвечает потребитель, либа дальше этот канал не использует и не мониторит
    close_channel в АПИ не выставляем, пользователь может вызывать сам amqp_channel:close(Pid)

- как работает либа (структура потоков и т.д.)

- samples


* info
http://www.rabbitmq.com/erlang-client-user-guide.html
https://www.rabbitmq.com/confirms.html
